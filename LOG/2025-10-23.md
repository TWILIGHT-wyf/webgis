## Leaflet 使用教程（Vue 3 + TypeScript + Vite 实战）

本文面向你的现有技术栈（Vue 3 + TS + Vite），提供从入门到实战的最小闭环：安装 → 基础地图 → 标记/弹窗 → 自定义图标 → GeoJSON → 圈选/聚合（可选）→ 常见坑与性能建议。

---

### 前置与安装

- 推荐使用 OpenStreetMap 瓦片作为基础底图。
- 在 Vite 工程中安装：

```powershell
npm i leaflet
npm i -D @types/leaflet
```

在入口引入样式（你项目已在 `src/main.ts` 引入）：

```ts
import 'leaflet/dist/leaflet.css'
```

---

### 最小可用地图组件 MapView.vue

功能：渲染 OSM 底图、比例尺、自适应、中心点标记，并修复 Vite 环境下默认图标不显示的问题。

```vue
<template>
  <div class="map-root">
    <div ref="mapEl" class="map-container" />
  </div>
</template>

<script setup lang="ts">
import { onMounted, onBeforeUnmount, ref, watch } from 'vue'
import * as L from 'leaflet'

// 可选 props：初始中心与缩放
const props = withDefaults(defineProps<{ center?: [number, number]; zoom?: number }>(), {
  center: () => [39.9042, 116.4074], // 北京
  zoom: 11,
})

const mapEl = ref<HTMLDivElement | null>(null)
let map: L.Map | null = null

// 修复默认 marker 图标（Vite 需显式引入资源）
import iconUrl from 'leaflet/dist/images/marker-icon.png'
import iconRetinaUrl from 'leaflet/dist/images/marker-icon-2x.png'
import shadowUrl from 'leaflet/dist/images/marker-shadow.png'
L.Icon.Default.mergeOptions({ iconUrl, iconRetinaUrl, shadowUrl })

onMounted(() => {
  if (!mapEl.value) return

  map = L.map(mapEl.value, {
    center: props.center,
    zoom: props.zoom,
    zoomControl: true,
  })

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors',
    maxZoom: 19,
  }).addTo(map)

  L.control.scale({ imperial: false }).addTo(map)

  // 示例：在中心点放一个 marker
  L.marker(props.center).addTo(map)

  // 自适应：容器变化时重算尺寸
  const resize = () => map?.invalidateSize()
  window.addEventListener('resize', resize)
  document.addEventListener('visibilitychange', resize)
  ;(map as any)._cleanup = () => {
    window.removeEventListener('resize', resize)
    document.removeEventListener('visibilitychange', resize)
  }
})

watch(
  () => props.center,
  (c) => map && c && map.setView(c),
)
watch(
  () => props.zoom,
  (z) => map && typeof z === 'number' && map.setZoom(z),
)

onBeforeUnmount(() => {
  if (map) {
    ;(map as any)._cleanup?.()
    map.remove()
    map = null
  }
})
</script>

<style scoped>
.map-root {
  width: 100%;
  height: 100%;
}
.map-container {
  width: 100%;
  height: 100%;
}
</style>
```

使用示例（页面全屏地图）：

```vue
<template>
  <div class="page"><MapView :center="center" :zoom="12" /></div>
</template>
<script setup lang="ts">
import MapView from '@/components/map/MapView.vue'
const center: [number, number] = [32.0603, 118.7969] // 南京
</script>
<style scoped>
.page {
  width: 100%;
  height: 100vh;
}
</style>
```

---

### 标记、弹窗与自定义图标

```ts
// 创建自定义图标
const poiIcon = L.icon({
  iconUrl,
  iconRetinaUrl,
  shadowUrl,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [0, -28],
})

// 添加标记与弹窗
const marker = L.marker([32.0603, 118.7969], { icon: poiIcon }).addTo(map!)
marker.bindPopup('<b>南京</b><br/>Hello Leaflet!')

// 打开/关闭弹窗
marker.openPopup()
marker.closePopup()
```

---

### 图层与图层控制器

```ts
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png')
const stamen = L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png')

const poiLayer = L.layerGroup()
L.marker([32.06, 118.79]).addTo(poiLayer)

L.control.layers({ OSM: osm, Toner: stamen }, { POI: poiLayer }).addTo(map!)

osm.addTo(map!)
poiLayer.addTo(map!)
```

---

### 加载并展示 GeoJSON

```ts
type FeatureProps = { id: string; name: string; status: 'ok' | 'warning' | 'error' }

const geojson = L.geoJSON<FeatureProps>(yourGeoJsonData, {
  pointToLayer: (feature, latlng) => {
    const color = feature.properties?.status === 'error' ? 'red' : 'blue'
    const svgIcon = L.divIcon({
      html: `<svg width="20" height="20"><circle cx="10" cy="10" r="8" fill="${color}"/></svg>`,
      className: 'poi-icon',
      iconSize: [20, 20],
      iconAnchor: [10, 10],
    })
    return L.marker(latlng, { icon: svgIcon })
  },
  onEachFeature: (feature, layer) => {
    layer.bindPopup(`${feature.properties?.name ?? '未命名'}`)
  },
})

geojson.addTo(map!)

// 视图自适应到所有要素
map!.fitBounds(geojson.getBounds(), { padding: [20, 20] })
```

---

### 事件与交互（点击、移动、缩放）

```ts
map!.on('click', (e) => {
  console.log('click at', e.latlng)
})

map!.on('moveend', () => {
  const c = map!.getCenter()
  const z = map!.getZoom()
  console.log('view ->', c, z)
})

marker.on('mouseover', () => marker.openPopup())
```

---

### 可选：圈选与空间计算（Leaflet.draw + Turf）

安装：

```powershell
npm i leaflet-draw @types/leaflet-draw turf
```

引入样式并添加控件：

```ts
import 'leaflet-draw/dist/leaflet.draw.css'
import 'leaflet-draw' // 仅 JS，无类型可用 @types/leaflet-draw

const drawnItems = new L.FeatureGroup().addTo(map!)
const drawControl = new L.Control.Draw({
  draw: {
    polygon: true,
    polyline: false,
    rectangle: true,
    circle: false,
    circlemarker: false,
    marker: false,
  },
  edit: { featureGroup: drawnItems },
})
map!.addControl(drawControl)

map!.on(L.Draw.Event.CREATED, (e: any) => {
  drawnItems.addLayer(e.layer)
  // 可将 e.layer.toGeoJSON() 与业务要素做空间筛选
})
```

使用 turf 示例（点是否在多边形内）：

```ts
import booleanPointInPolygon from '@turf/boolean-point-in-polygon'
// booleanPointInPolygon(point, polygon)
```

---

### 可选：大量点聚合（markercluster）

```powershell
npm i leaflet.markercluster
```

```ts
import 'leaflet.markercluster'
const cluster = L.markerClusterGroup()
yourPoints.forEach((p) => L.marker([p.lat, p.lng]).addTo(cluster))
cluster.addTo(map!)
```

建议：5k+ 点优先聚合，避免一次性渲染大量 DOM marker。

---

### 与状态管理/路由的联动思路

- 在 Pinia 中维护当前选中要素 ID、过滤条件、视图状态（中心与缩放），在地图和列表间共享。
- 路由查询串（query）同步筛选与选中，支持刷新与分享链接复现状态。
- 复杂数据请求建议使用 @tanstack/vue-query 处理缓存/重试/失焦刷新。

---

### 常见坑与排错

1. 地图容器不显示/高度为 0：

- 确保容器有明确高度（如 100vh 或父容器给定高度）。

2. 默认 marker 图标丢失：

- 在 Vite 中需显式引入图片资源，并 `L.Icon.Default.mergeOptions` 指定。

3. 初次渲染尺寸错误（只显示一角）：

- 组件显示后调用 `map.invalidateSize()`；或在 window resize/visibilitychange 事件触发时调用。

4. 跨域与瓦片限速：

- 使用公共瓦片需遵守服务条款，避免大规模缓存；生产建议自建或购买底图服务。

5. 性能：

- 大量点位优先用聚合；减少频繁重绘；复杂样式用 Canvas/DivIcon；谨慎在高频事件中 setState。

---

### API 速查（常用）

- 地图：`L.map(el)`, `map.setView([lat,lng], zoom)`, `map.fitBounds(bounds)`
- 底图：`L.tileLayer(urlTemplate, options)`
- 标记：`L.marker([lat,lng], { icon })`, `marker.bindPopup(html)`, `marker.setLatLng()`
- 矢量：`L.polyline(coords)`, `L.polygon(coords)`, `L.circle([lat,lng], { radius })`
- 分组：`L.layerGroup()`, `L.featureGroup()`，`L.control.layers(base, overlays)`
- GeoJSON：`L.geoJSON(data, { onEachFeature, pointToLayer, style })`
- 事件：`map.on('click'|'moveend'|...)`, `layer.on('mouseover'|...)`

---

以上即在你当前项目环境下的 Leaflet 实战指南。若需要，我可以把上述 MapView 组件与可运行页面直接落到 `src/components/map/MapView.vue` 与页面路由中，并补充设施示例数据（GeoJSON）与联动演示。
